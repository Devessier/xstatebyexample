---
id: 1
title: "Debouncing"
image:
  source: "fs"
  url: "../../assets/examples-images/debouncing.png"
visualizerSrc: "https://stately.ai/registry/editor/embed/ffb84170-4403-4304-889d-3eefadc0465b?mode=Design&machineId=a5823380-73ed-475b-ba67-73c09f421074"
complexity: "beginner"
youtubeVideoId: "sgg_K1yaG7o"
---

import DemoEntrypoint from "../../examples/debouncing/index.tsx";

The debouncing pattern is crucial to UI development.
Debouncing – and [throttling](/throttling/) – are used to moderate
how much a function is called on a time basis.

When we _debounce_ a function by 200ms, the function will be _actually_ called only 200ms
after the function has been called for the last time.
If the function is called again before the timer ends,
the timer is aborted, and another one is started; the function is not called.

There are many use cases for debouncing, mostly every time you want to perform time-consuming tasks.
The one I genuinely love is search-as-you-type. There is [a machine implementing it](/search-as-you-type/),
so check it out!

## Example

Try incrementing the counter by clicking the `Increment` button below.
The counter will be incremented one second after you stop clicking the button.

The state machine is resilient to spamming. It controls how it should behave if the user abuses the button.

<DemoEntrypoint client:load />
