---
id: 2
title: "Throttling"
image:
  url: "https://stately.ai/registry/machines/610df47a-3ecd-4f55-9dea-6f97edf05ea0.light.png"
  width: 1377
  height: 600
complexity: "beginner"
---

import Tabs from '../../components/Tabs.tsx';
import DemoEntrypoint from '../../components/throttling/index.tsx';
import StatelyVisualizer from '../../components/StatelyVisualizer.astro';
import { Content as DemoMachineCode } from '../../components/throttling/machine.md';
import { Content as DemoReactCode } from '../../components/throttling/Demo.md';

The throttling pattern looks like the [debouncing](/debouncing/) one, but instead of restarting a timer when the machine receives an event, it stops listening to events temporarily.

In the following example, when the machine receives the first `click` event, it goes into the `Throttling` state. The `click` event is not listened by the machine in this state. The `Throttling` state starts a timer of one second, which targets the `Idle` state.

## Example

Try incrementing the counter by clicking the `Increment` button below.
The counter will be incremented once every second.

The state machine is resilient to spamming. It controls how it should behave if the user abuses the button.

<DemoEntrypoint client:load />

## Code

<Tabs labels={['Machine', 'React', 'Visualizer']} client:load>
  <Fragment slot="1">
    <DemoMachineCode />
  </Fragment>

  <Fragment slot="2">
    <DemoReactCode />
  </Fragment>

  <Fragment slot="3">
    <StatelyVisualizer src="https://stately.ai/registry/editor/embed/ffb84170-4403-4304-889d-3eefadc0465b?mode=design&machineId=610df47a-3ecd-4f55-9dea-6f97edf05ea0" />
  </Fragment>
</Tabs>
